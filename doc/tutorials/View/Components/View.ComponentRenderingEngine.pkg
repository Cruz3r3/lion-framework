<refentry id="{@id}">
 <refnamediv>
  <refname>The Component Rendering Engine</refname>
  <refpurpose>Handling user interface controls</refpurpose>
 </refnamediv>
 <refsynopsisdiv>
 </refsynopsisdiv>
{@toc}
 <para></para>
 <refsect1 id="{@id comp_render_model}">
  <title>The component rendering engine</title>
  <para>The component rendering engine has been designed in order to parse component tags from templates and generate the code that makes them work. This code is automagically generated by the component rendering engine just the first time the template is compiled, avoiding performance penalties.</para>
  <para>Component tags are custom tags used within the template to place controls into the user interface.<br/>
  When the component rendering engine parses a template, it localizes all the component tags and replaces them by code to handle the component display and the event broadcasting.</para>
 </refsect1>
 <refsect1 id="{@id component_tag_language}">
  <title>Component Tag Language</title>
  <para>The component tag language defines the syntax and rules to put components within the user interface.</para>
  <para>This tag based language is allowed just in views subclassing the {@link __TemplateEngineView}. Out of the box, Lion has the {@link __SmartyView} class which uses the Smarty template engine to render the user interface. In fact, this is the default view used by Lion if no other is specified.</para>
  <para>The component rendering engine is installed as a post-filter, which means that once the template engine has parsed the template, it executes the component rendering engine to filter the templatized content. The class in charge of parsing the template to locate component tags is the {@link __ComponentFilter}, which subclass the {@link __TemplateFilter} as a post-filter.<br/>
  This is the reason because a {@link __TemplateEngineView} subclass is required to be able to use the component tag language.</para>
 <refsect2 id="{@id defining_components}">
  <title>Defining Components</title>
  <para>A component tag has the following syntax:</para>
  <floatnote>
    <para>Do not assign template placeholders to component properties.<br/>
    To initialize a component with a value taken from the model, use the {@link __EventHandler::init()} method.</para>
    <para>See the {@tutorial View/Components/View.EventManagementSystem.pkg} section for more information.</para>
  </floatnote>
  <para>
  <syntaxdefinition>
  &lt;comp:<italic>component-tag-name</italic> <br/>
  &nbsp;&nbsp;&nbsp;&nbsp;[name="<italic>component-name</italic>"]<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;[<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<italic>property = value</italic><br/>
  &nbsp;&nbsp;&nbsp;&nbsp;]*<br/>
  /&gt;<br/>
  </syntaxdefinition>
  </para>
  <para>where<br/>
  <itemizedlist>
    <listitem><emphasis>component-tag-name</emphasis> is a name identifying the component that the tag represents to (i.e. commandbutton, inputbox, ...).</listitem>
    <listitem><emphasis>component-name</emphasis> is a name to identify a concrete component instance. This parameter is optional. If no names are supplied, a default one will be assigned to the component.</listitem>
    <listitem>The list of pair <emphasis>property-value</emphasis> is a set of initial values to setup a component.</listitem>
  </itemizedlist>
  </para>
  <para>i.e.
    {@example View/Components/componentsExample1.tpl}
  In this example, we have defined 2 components, a command button and an input box.<br/>
  An yes, components are defined within the template content as part of.</para>
 </refsect2>
 <refsect2 id="{@id defining_containers}">
  <title>Defining Containers</title>
  <para>A component can be also defined by ussing a pair begin-end tags. It allows to close a piece of template content:</para>
  <para>
  <syntaxdefinition>
  &lt;comp:<italic>component-tag-name</italic> <br/>
  &nbsp;&nbsp;&nbsp;&nbsp;[name="<italic>component-name</italic>"]<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;[<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<italic>property = value</italic><br/>
  &nbsp;&nbsp;&nbsp;&nbsp;]*<br/>
  &gt;<br/>
  <br/>
  ...<br/>
  <br/>
  &lt;/comp:<italic>component-tag-name</italic>&gt;<br/>
  </syntaxdefinition>
  </para>
  <para>In that case, the content closed by the component can also contain other component tags. In that case, the component acts as container.</para>
  <para>i.e.
    {@example View/Components/componentsExample2.tpl}
  </para>
 </refsect2>
 <refsect2 id="{@id defining_properties}">
  <title>Defining Properties</title>
  <para>Finally, a component can define properties within the enclosed area by ussing the <emphasis>comp-property</emphasis> tag.<br/>
  This is really usefull to assign components as property for other components.</para>
  <para>
  The syntax for ussing the comp-property is the following one:</para>
  <para>
  <syntaxdefinition>
  &lt;comp-property name="<italic>property-name</italic>"&gt;<br/>
  &nbsp;&nbsp;&nbsp;&nbsp;(property value goes here)<br/>
  &lt;/comp-property&gt;<br/>
  </syntaxdefinition>
  </para>
  <para>i.e.
    {@example View/Components/componentsExample3.tpl}
    In this example we are using the comp-property tag to assign a component to the caption property.
  </para>
  <para>It's really important to note that we can not use template placeholders as attribute values within component tags, because the template is processed before the component render engine parses it.</para>
  <para>However, Lion offers a workarround by ussing the tag comp-property as we have seen. i.e.:
    {@example View/Components/componentsExample3bis.tpl}
    In this example, we can not assign directly the placeholder <italic>about_us_literal</italic> as an attribute value, but we have the workarround of ussing the comp-property tag for the same purpose.</para>
 </refsect2>
 <para>Try {@tutorial Lion/Tutorials/Lion.tutorial3.pkg}. It contains a practical tutorial regarding components and event handlers.</para>
 </refsect1>
</refentry>
